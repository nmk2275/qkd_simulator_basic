<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quantum Key Distribution Simulator (Research Edition)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
:root{
  --bg1:#0a2714; --bg2:#082211;
  --accent1:#10b981; --accent2:#22d3ee; --danger:#ef4444;
  --glass: rgba(255,255,255,0.03);
}
html,body{
  height:100%;margin:0;
  background:
    radial-gradient(900px 400px at 10% 12%, rgba(16,185,129,0.03), transparent),
    linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 100%);
  color:#e9f7ff;
  font-family:Inter,Segoe UI,system-ui,Arial,sans-serif;
}
header {
  background: linear-gradient(90deg,var(--accent1),var(--accent2));
  color: white;
  text-align: center;
  padding: 1.2rem;
  font-size: 1.5rem;
  font-weight: 700;
  border-radius: 0 0 18px 18px;
  box-shadow: 0 2px 16px rgba(0,0,0,0.18);
  letter-spacing: 1px;
}
.container {
  max-width: 1200px;
  margin: 2rem auto;
  padding: 2rem;
  background: var(--glass);
  border-radius: 18px;
  box-shadow: 0 4px 32px rgba(16,185,129,0.08);
}
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}
.control {
  margin: 1.5rem 0;
}
label {
  font-weight: 700;
  display: block;
  margin-bottom: 0.5rem;
  color: #bfe8ff;
}
input[type=range], select {
  width: 100%;
  accent-color: var(--accent1);
}
.output {
  margin-top: 0.5rem;
  font-size: 1rem;
  color: #bfe8ff;
}
canvas {
  width: 100% !important;
  height: 350px !important;
  background: rgba(255,255,255,0.01);
  border-radius: 12px;
  box-shadow: 0 2px 12px rgba(16,185,129,0.08);
}
button {
  background: linear-gradient(90deg,var(--accent1),var(--accent2));
  color: white;
  padding: 0.6rem 1.2rem;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  cursor: pointer;
  margin-top: 1.5rem;
  font-weight: 700;
  box-shadow: 0 2px 8px rgba(16,185,129,0.10);
  transition: background 0.18s;
}
button:hover {
  background: linear-gradient(90deg,#22d3ee,#10b981);
}
.formula-section {
  margin-top: 2rem;
  padding: 1rem;
  background: rgba(255,255,255,0.04);
  border-radius: 12px;
  font-size: 1rem;
  line-height: 1.5;
  color: #e9f7ff;
  box-shadow: 0 2px 8px rgba(16,185,129,0.06);
}
.formula-section h3 {
  color: var(--accent2);
  margin-bottom: 0.5rem;
}
code {
  background: #183c23;
  padding: 2px 5px;
  border-radius: 4px;
  font-family: monospace;
  color: #a7ffeb;
}
#protocol {
  appearance: none;
  background: #183c23;
  border: 2px solid #10b981;
  border-radius: 8px;
  padding: 0.6rem 1rem;
  font-size: 1rem;
  font-weight: 500;
  color: #e9f7ff;
  cursor: pointer;
  transition: border 0.2s, box-shadow 0.2s;
}
#protocol:hover, #protocol:focus {
  border-color: var(--accent2);
  box-shadow: 0 0 6px rgba(34,211,238,0.3);
  outline: none;
}
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0; top: 0; width: 100%; height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.5);
}
.modal-content {
  background: linear-gradient(180deg,#083046,#062438);
  margin: 10% auto;
  padding: 2rem;
  border-radius: 18px;
  width: 60%;
  box-shadow: 0 4px 24px rgba(16,185,129,0.18);
  color: #e5f6ff;
}
.modal-content h2 {
  margin-top: 0;
  color: var(--accent2);
}
.close {
  float: right;
  font-size: 1.5rem;
  font-weight: bold;
  cursor: pointer;
  color: #fff;
}
@media (max-width: 900px) {
  .grid { grid-template-columns: 1fr; }
  .container { padding: 1rem; }
  .modal-content { width: 92%; }
}
  </style>
</head>
<body>
  <header>Quantum Key Distribution Simulator (Research Edition)</header>
  <div class="container">

    <!-- Protocol Selection -->
    <div class="control">
      <label for="protocol">QKD Protocol</label>
      <select id="protocol">
        <option value="bb84">BB84</option>
        <option value="decoy">Decoy-State BB84</option>
      </select>
    </div>

    <!-- Distance Control -->
    <div class="control">
      <label for="distanceSlider">Fiber Distance (km)</label>
      <input type="range" id="distanceSlider" min="0" max="200" value="50">
      <div class="output">Distance: <span id="distanceValue">50</span> km</div>
    </div>

    <!-- Photon Level Control -->
    <div class="control">
      <label for="photonSlider">Mean Photons per Pulse (μ)</label>
      <input type="range" id="photonSlider" min="0.1" max="1.0" step="0.1" value="0.5">
      <div class="output">Photons per pulse: <span id="photonValue">0.5</span></div>
    </div>
     <!-- How it works -->
    <button id="howItWorksBtn">How this works?</button>
    <div id="howItWorksModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>How the QKD Simulator Works</h2>
    <p>This simulator models the behavior of Quantum Key Distribution (QKD) protocols over optical fibers.</p>
    
    <h3>Key Concepts:</h3>
    <ul>
      <li><strong>Transmission (T):</strong> Signal photons are attenuated by fiber loss (<code>α · d</code>), so fewer reach the detector as distance grows.</li>
      <li><strong>Detector Efficiency (η):</strong> Only a fraction of the photons arriving are detected.</li>
      <li><strong>Dark Counts:</strong> Detectors sometimes click without photons, introducing errors.</li>
      <li><strong>QBER:</strong> The Quantum Bit Error Rate reflects the ratio of erroneous bits to total detections.</li>
      <li><strong>Key Rate:</strong> The secure key rate is derived using the Shor–Preskill bound and decreases as errors grow.</li>
      <li><strong>Protocols:</strong> 
        <ul>
          <li><strong>BB84:</strong> Baseline QKD protocol.</li>
          <li><strong>Decoy-State BB84:</strong> More robust against photon-number-splitting attacks, yielding slightly higher secure key rates.</li>
        </ul>
      </li>
    </ul>

    <h3>How Key Rate & QBER Change with Distance:</h3>
    <ul>
      <li><strong>Key Rate:</strong> Decreases <em>exponentially</em> with distance because optical fiber attenuates photons. At long distances, the secure key rate approaches zero.</li>
      <li><strong>QBER:</strong> Increases with distance. As the signal weakens, dark counts and noise dominate, pushing QBER higher (often beyond the 11%–15% threshold where secure key generation is no longer possible).</li>
      <li><strong>Threshold:</strong> Once QBER exceeds this limit, no secret key can be extracted, even if detections occur.</li>
    </ul>
  </div>
</div>


    <!-- Advanced Parameters -->
    <div class="grid">
      <div>
        <label for="eta">Detector Efficiency (η)</label>
        <input type="range" id="eta" min="0.05" max="0.3" step="0.01" value="0.1">
        <div class="output">η = <span id="etaValue">0.10</span></div>

        <label for="dark">Dark Count Rate</label>
        <input type="range" id="dark" min="10" max="1000" step="10" value="100">
        <div class="output">Dark = <span id="darkValue">100</span> cps</div>
      </div>
      <div>
        <label for="repRate">Repetition Rate (Hz)</label>
        <input type="range" id="repRate" min="1e5" max="1e7" step="1e5" value="1000000">
        <div class="output">RepRate = <span id="repRateValue">1000000</span></div>

        <label for="alpha">Fiber Loss (dB/km)</label>
        <input type="range" id="alpha" min="0.1" max="0.5" step="0.01" value="0.2">
        <div class="output">α = <span id="alphaValue">0.20</span> dB/km</div>
      </div>
    </div>

    <!-- Results -->
    <div class="output">
      <strong>Quantum Bit Error Rate (QBER):</strong> <span id="qberValue">0</span> %<br>
      <strong>Secret Key Rate:</strong> <span id="keyRateValue">0</span> bps
    </div>

    <!-- Graphs in Horizontal Layout -->
    <div class="grid">
      <canvas id="rateChart"></canvas>
      <canvas id="qberChart"></canvas>
    </div>

    <!-- Formula Section -->
    <div class="formula-section">
      <h3>Formulas Used</h3>
      <p><strong>Transmission:</strong>  
        <code>T = 10<sup>-(α·d / 10)</sup></code>  
        where <code>α</code> is fiber loss (dB/km), <code>d</code> is distance (km).</p>

      <p><strong>Signal Counts:</strong>  
        <code>S = μ · η · RepRate · T</code>  
        where <code>μ</code> is mean photons, <code>η</code> detector efficiency.</p>

      <p><strong>Quantum Bit Error Rate (QBER):</strong>  
        <code>QBER = (e₀·S + 0.5·Dark) / (S + Dark)</code></p>

      <p><strong>Secret Key Rate:</strong>  
        <code>R = S × max(0, 1 - 2·h₂(QBER))</code></p>
    </div>
  </div>
  <!-- Modal (hidden by default) -->


<script>
function h2(x) {
  if (x <= 0 || x >= 1) return 0;
  return -x * Math.log2(x) - (1-x) * Math.log2(1-x);
}

function simulate(distance_km, mu, params, protocol) {
  const { rep_rate, eta, dark, e0, alpha } = params;

  const T = Math.pow(10, -alpha * distance_km / 10);
  const S = mu * eta * rep_rate * T;

  let QBER = (e0 * S + 0.5 * dark) / (S + dark);
  let keyRate = S * Math.max(0, 1 - 2 * h2(QBER));

  // Protocol adjustments
  if (protocol === "decoy") {
    keyRate *= 1.2; // decoy gives ~20% boost
  } else if (protocol === "e91") {
    QBER += 0.01;
    keyRate *= 0.9;
  } else if (protocol === "cvqkd") {
    QBER = Math.min(0.15, QBER + 0.05);
    keyRate *= 1.5;
  }

  return {QBER, keyRate};
}

// Charts
const ctx1 = document.getElementById('rateChart').getContext('2d');
const rateChart = new Chart(ctx1, {
  type: 'line',
  data: { datasets: [{ label: 'Key Rate vs Distance', data: [], borderColor: '#1d4ed8', fill: true, backgroundColor: 'rgba(29,78,216,0.15)', tension: 0.25 }] },
  options: { maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'Distance (km)' } }, y: { beginAtZero: true, title: { display: true, text: 'Key Rate (bps)' } } }, plugins: { legend: { display: false } } }
});

const ctx2 = document.getElementById('qberChart').getContext('2d');
const qberChart = new Chart(ctx2, {
  type: 'line',
  data: { datasets: [{ label: 'QBER vs Distance', data: [], borderColor: '#dc2626', fill: true, backgroundColor: 'rgba(220,38,38,0.15)', tension: 0.25 }] },
  options: { maintainAspectRatio: false, scales: { x: { type: 'linear', title: { display: true, text: 'Distance (km)' } }, y: { min: 0, max: 0.5, title: { display: true, text: 'QBER (0–0.5)' } } }, plugins: { legend: { display: false } } }
});

function update() {
  const distance = parseFloat(document.getElementById('distanceSlider').value);
  const mu = parseFloat(document.getElementById('photonSlider').value);
  const protocol = document.getElementById('protocol').value;

  const params = {
    eta: parseFloat(document.getElementById('eta').value),
    dark: parseFloat(document.getElementById('dark').value),
    rep_rate: parseFloat(document.getElementById('repRate').value),
    alpha: parseFloat(document.getElementById('alpha').value),
    e0: 0.01
  };

  document.getElementById('distanceValue').textContent = distance;
  document.getElementById('photonValue').textContent = mu.toFixed(1);
  document.getElementById('etaValue').textContent = params.eta.toFixed(2);
  document.getElementById('darkValue').textContent = params.dark;
  document.getElementById('repRateValue').textContent = params.rep_rate;
  document.getElementById('alphaValue').textContent = params.alpha.toFixed(2);

  const result = simulate(distance, mu, params, protocol);
  document.getElementById('qberValue').textContent = (result.QBER*100).toFixed(2);
  document.getElementById('keyRateValue').textContent = result.keyRate.toFixed(2);

  let dataRate = [], dataQber = [];
  for (let d = 0; d <= distance; d += 2) {
    const r = simulate(d, mu, params, protocol);
    dataRate.push({x: d, y: Math.max(1e-6, r.keyRate)});
    dataQber.push({x: d, y: r.QBER});
  }

  rateChart.data.datasets[0].data = dataRate;
  rateChart.options.scales.x.max = distance;
  rateChart.update();

  qberChart.data.datasets[0].data = dataQber;
  qberChart.options.scales.x.max = distance;
  qberChart.update();
}

// Event listeners
["distanceSlider","photonSlider","eta","dark","repRate","alpha","protocol"].forEach(id => {
  document.getElementById(id).addEventListener('input', update);
});

// Initial render
update();
// Modal functionality
const modal = document.getElementById("howItWorksModal");
const btn = document.getElementById("howItWorksBtn");
const span = document.querySelector(".close");

btn.onclick = () => modal.style.display = "block";
span.onclick = () => modal.style.display = "none";
window.onclick = (event) => {
  if (event.target === modal) {
    modal.style.display = "none";
  }
};

</script>
</body>
</html>