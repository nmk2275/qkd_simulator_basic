<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>QKD Packet-Tracer Style Simulator ‚Äî BB84</title>
<style>
:root{
  --bg1:#0a2714; --bg2:#082211;
  --accent1:#10b981; --accent2:#22d3ee; --danger:#ef4444;
  --glass: rgba(255,255,255,0.03);
}
*{box-sizing:border-box;font-family:Inter,Segoe UI,system-ui,Arial,sans-serif}
html,body{height:100%;margin:0;background:
  radial-gradient(900px 400px at 10% 12%, rgba(139,92,246,0.03), transparent),
  linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 100%); color:#e9f7ff}

.app {display:flex;min-height:100vh}

/* Sidebar */
.sidebar{
  width:300px;padding:18px;border-right:1px solid rgba(255,255,255,0.02);
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
}
.header {display:flex;align-items:center;gap:12px;margin-bottom:12px}
.header h1{font-size:18px;margin:0}
.toolbox .tool {background:var(--glass);padding:10px;border-radius:10px;margin-bottom:10px;cursor:grab;border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;align-items:center}
.tool .emoji{width:46px;height:46px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:22px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff}

/* Main */
.canvas-wrap{flex:1;display:flex;flex-direction:column}
.topbar{display:flex;align-items:center;gap:12px;padding:12px 18px}
.topbar .title{font-weight:700}
.topbar .right{margin-left:auto;display:flex;align-items:center;gap:10px}

/* workspace / stage */
.stage{flex:1;margin:12px;border-radius:12px;padding:12px;position:relative;overflow:hidden}
.workspace{position:relative;height:68vh;border-radius:10px;background:
  radial-gradient(800px 300px at 20% 10%, rgba(124,58,237,0.02), transparent),
  linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));}

/* svg cable */
.workspace svg{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}

/* nodes */
.node{position:absolute;width:120px;height:120px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:grab;border:1px solid rgba(255,255,255,0.03);box-shadow:0 10px 30px rgba(0,0,0,0.45)}
.node .avatar{width:82px;height:82px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:36px;color:#fff;background:linear-gradient(135deg,var(--accent1),var(--accent2));border:3px solid rgba(255,255,255,0.04)}
#node-eve .avatar{background:linear-gradient(135deg,#ef4444,#fb923c)}
#node-passive_eve .avatar {
    background: linear-gradient(135deg, #FFD700, #FFC107);
}
.node .label{margin-top:8px;font-weight:700;color:#eaf8ff;text-transform:uppercase;letter-spacing:0.6px}

/* panels under workspace */
.side-panels{display:flex;gap:12px;margin-top:12px}
.panel{background:var(--glass);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);flex:1}
.panel h3{margin:0 0 8px 0}
.qubit-row{display:flex;gap:8px;flex-wrap:wrap}
.qubit-picker{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;min-width:110px}
.btn{padding:8px 12px;border-radius:8px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;border:none;cursor:pointer;font-weight:700}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dff1ff}

/* photon */
.photon{position:absolute;width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff3c4,#ffd24d);color:#111;font-weight:800;border:2px solid rgba(0,0,0,0.12);box-shadow:0 10px 26px rgba(255,200,80,0.12)}
.photon .basis{position:absolute;top:-14px;font-size:12px;color:rgba(0,0,0,0.6)}

/* key display */
.final-key{margin-top:12px;padding:12px;border-radius:12px;background:linear-gradient(90deg,#ffd54d,#ffb86b);color:#111;font-weight:800;display:inline-block;box-shadow:0 12px 40px rgba(255,150,50,0.12)}

/* modal */
.modal-back{position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999}
.modal{width:92%;max-width:900px;background:linear-gradient(180deg,#083046,#062438);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);color:#e5f6ff;max-height:86vh;overflow:auto}
h2{margin-top:0}

/* speech */
.speech{position:absolute;padding:8px 12px;border-radius:12px;background:rgba(0,0,0,0.55);color:white;font-size:13px;max-width:300px;opacity:0;transform:translateY(6px);transition:all .36s}
.speech.show{opacity:1;transform:translateY(0)}
.speech.Sender{left:18px;top:8px;background:linear-gradient(90deg,var(--accent1),var(--accent2))}
.speech.Receiver{right:18px;top:8px;background:linear-gradient(90deg,#10b981,#06b6d4)}
.speech.eve{left:50%;transform:translateX(-50%);top:8px;background:linear-gradient(90deg,#ef4444,#fb923c)}

/* small note */
.note{font-size:13px;color:#bfe8ff;margin-top:8px}

/* responsive */
@media(max-width:1000px){
  .sidebar{display:none}
  .workspace{height:60vh}
  .side-panels{flex-direction:column}
}

.features-btn {
  padding: 8px 12px;
  border-radius: 8px;
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  color: #fff;
  border: none;
  cursor: pointer;
  font-weight: 700;
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background: #133c23;
  min-width: 170px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.18);
  border-radius: 8px;
  z-index: 1000;
  padding: 8px 0;
  border: 1px solid rgba(16,185,129,0.18);
  right: 0;
}

.dropdown-content a {
  color: #e9f7ff;
  padding: 10px 18px;
  text-decoration: none;
  display: block;
  font-size: 15px;
  border-radius: 6px;
  transition: background 0.18s;
}

.dropdown-content a:hover {
  background: linear-gradient(90deg,#10b981,#22d3ee);
  color: #fff;
}

.dropdown:hover .dropdown-content {
  display: block;
}
#userMessage {
  background: rgba(255,255,255,0.07);
  color: #e9f7ff;
  border: 1px solid #10b981;
  border-radius: 6px;
  padding: 6px 10px;
  margin-top: 4px;
}
#cryptoOutput b { color: #22d3ee; }
.node.selected {
  outline: 3px solid #22d3ee;
  z-index: 10;
}
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="header"><h1>üîê QKD Simulator</h1></div>

    <div class="toolbox">
      <div class="small">Drag components to the canvas (or click Fiber then nodes to connect)</div>

      <div id="toolSender" class="tool" draggable="true" data-tool="Sender">
        <div class="emoji">üñ•Ô∏è</div>
        <div><div style="font-weight:700">Sender</div><div class="small"></div></div>
      </div>

      <div id="toolReceiver" class="tool" draggable="true" data-tool="Receiver">
        <div class="emoji">üíª</div>
        <div><div style="font-weight:700">Receiver</div><div class="small"></div></div>
      </div>

      <div id="toolEve" class="tool" draggable="true" data-tool="eve">
        <div class="emoji">üïµÔ∏è</div>
        <div><div style="font-weight:700">Eve</div><div class="small">Intruder</div></div>
      </div>
       <div id="toolPassive_eve" class="tool" draggable="true" data-tool="passive_eve">
        <div class="emoji">ü•∑</div>
        <div><div style="font-weight:700">Passive eve</div><div class="small"></div></div>
      </div>

      <div id="toolFiber" class="tool" draggable="true" data-tool="fiber">
        <div class="emoji">üîó</div>
        <div><div style="font-weight:700">Fiber</div><div class="small">Click node A ‚Üí node B</div></div>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="undoBtn" class="btn secondary" style="flex:1">Undo</button>
        <button id="redoBtn" class="btn secondary" style="flex:1">Redo</button>
        <button id="clearBtn" class="btn secondary" style="flex:1">Clear</button>
        <button id="deleteBtn" class="btn secondary" style="flex:1">Delete</button>
      </div>
      <div style="margin-top:12px;display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="toggleErrorMitigation" />
      <label for="toggleErrorMitigation" class="small">Error Mitigation</label>
      </div>
      <div style="margin-top:14px">
        <button id="howBtn" class="btn secondary" style="width:100%">How it works</button>
      </div>

      <div class="note">
        <strong>Quick steps</strong>
        <ol style="padding-left:18px;margin-top:6px">
          <li>Drag Sender & Receiver to the canvas</li>
          <li>Drag Fiber then click Sender ‚Üí Receiver to connect</li>
          <li>Place Eve on or near the fiber to intercept</li>
          <li>Prepare bits/bases, Send Qubits, Measure, Sift, Encrypt</li>
        </ol>
      </div>
    </div>
  </aside>

  <div class="canvas-wrap">
   <div class="topbar">
  <div class="title">Packet-Tracer Style QKD ‚Äî BB84</div>
  <div class="right" style="display:flex;align-items:center;gap:12px;">
    <div class="small">Drag components ‚Üí connect ‚Üí simulate</div>
   <style>
.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  color: black;
  padding: 8px 12px;
  text-decoration: none;
  display: block;
}

.dropdown-content a:hover {
  background-color: #10b981;
}

.dropdown:hover .dropdown-content {
  display: block;
}
</style>

<div class="dropdown">
  <button class="features-btn">Features</button>
  <div class="dropdown-content">
    <a href="https://simulation-89hn39oimedaemad9brkbr.streamlit.app/">Basic Simulation</a>
    <a href="/keyrate">Extended QKD</a>
    <a href="/KeyrateVsDistance">Keyrate vs Distance</a>
    <a href="https://multiuser.streamlit.app/">Multi user</a>
    <a href="/shors">Shor's Algorithm</a>
  </div>
</div>

  </div>
  <button id="showAnalysisBtn" class="btn secondary" style="margin-left:12px;">üî¨ Analysis</button>
</div>

    <div class="stage">
      <div id="workspace" class="workspace">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>

        <div id="speechSender" class="speech Sender">Place Sender</div>
        <div id="speechReceiver" class="speech Receiver">Place Receiver</div>
        <div id="speechEve" class="speech eve">Place Eve</div>
      </div>

      <div style="margin:20px; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px;">
        <h3>‚öõÔ∏è IBM Quantum Experiments</h3>
       <button id="runExpBtn" class="btn">Run Experiment</button>

        <pre id="output" style="margin-top:12px; background:rgba(0,0,0,0.4); padding:10px; border-radius:8px; color:#bfe8ff; max-height:250px; overflow:auto;"></pre>
      </div>

      
      <div id="analysisPanel" style="display:none; background:rgba(0,0,0,0.7); color:#e9f7ff; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:9999; align-items:center; justify-content:center;">
 <div style="background:linear-gradient(180deg,#083046,#062438); border-radius:18px; padding:32px; max-width:700px; margin:40px auto; box-shadow:0 8px 32px rgba(16,185,129,0.18); max-height:90vh; overflow:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <h2 style="margin:0;">üî¨ QKD Analysis</h2>
      <button id="closeAnalysisBtn" class="btn secondary" style="font-size:1.2em;">‚úñ</button>
    </div>
    <div id="circuitDiagram" style="margin-top:18px;"></div>
    <div id="histogram" style="margin-top:18px;"></div>
    <div id="qberCalc" style="margin-top:18px;"></div>
  </div>
</div>
      

<div id="modal" class="modal-back" role="dialog" aria-hidden="true">
  <div class="modal">
    <h2>How BB84 QKD works ‚Äî short & visual</h2>
    <h3>Bits vs Bases</h3>
    <p><strong>Bits</strong> are binary values 0 and 1. <br>
       <strong>Bases</strong> are how we encode bits into photon polarization:
       <ul>
         <li><strong>+</strong> rectilinear (vertical/horizontal) ‚Äî think | = 0, ‚Äî = 1</li>
         <li><strong>√ó</strong> diagonal (/ and \) ‚Äî think / = 0, \ = 1</li>
       </ul>
    </p>
    <h3>Protocol Steps (this simulator)</h3>
    <ol>
      <li>Sender prepares qubits: each qubit = (bit, basis) and sends photons over the fiber.</li>
      <li>Receiver measures each photon with a random basis. If his basis = Sender's basis ‚Üí correct bit; else random.</li>
      <li>Sender & Receiver publicly compare bases (not bits) and keep positions with matching bases ‚Üí sifted key.</li>
      <li>If Eve intercepts and resends, she introduces errors in matched positions ‚Äî detectable by Sender/Receiver.</li>
      <li>The sifted key is used to derive an encryption key (this demo uses a SHA-256 ‚Üí AES-GCM approach for clarity).</li>
    </ol>
    <div style="text-align:right;margin-top:12px"><button id="closeModal" class="btn">Close</button></div>
  </div>
</div>

<script>
/* -----------------------
   Complete QKD Simulator Script
   ----------------------- */
let undoStack = [];
let redoStack = [];


/* Globals & state */
const workspace = document.getElementById('workspace');
const svg = document.getElementById('svg');
let nodes = [];    // {id,type,el,x,y}
let cables = [];   // {id,fromId,toId,path}
let nextId = 1;
let selectedNodeId = null;
let connectMode = false;
let connectStart = null;
let dragging = null;

let dragOffset = {x:0,y:0};

let SenderBits = [], SenderBases = [], ReceiverChoices = [], ReceiverResults = [], perPhotonEve = [];
let photonsInFlight = 0;
let derivedKey = null;

/* UI refs */
const speechSender = document.getElementById('speechSender');
const speechReceiver   = document.getElementById('speechReceiver');
const speechEve   = document.getElementById('speechEve');

function $(id){ return document.getElementById(id); }
function randBit(){ return Math.random() < 0.5 ? 0 : 1 }
function randBasis(){ return Math.random() < 0.5 ? '+' : 'x' }

/* show bubble */
function showBubble(who,text){
  const el = who==='Sender' ? speechSender : who==='Receiver' ? speechReceiver : speechEve;
  el.innerText = text; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),2200);
}

/* TOOL: make toolbox items draggable onto workspace */
['toolSender','toolReceiver','toolEve','toolFiber','toolPassive_eve'].forEach(id=>{
  const t = document.getElementById(id);
  t.addEventListener('dragstart', e => { e.dataTransfer.setData('tool', id); });
});

/* workspace drag/drop */
workspace.addEventListener('dragover', e=> e.preventDefault());
workspace.addEventListener('drop', e=>{
  e.preventDefault();
  const tool = e.dataTransfer.getData('tool');
  if (!tool) return;
  const rect = workspace.getBoundingClientRect();
  const x = e.clientX - rect.left - 60;
  const y = e.clientY - rect.top - 60;
  if (tool === 'toolFiber'){
    connectMode = true; connectStart = null;
    showBubble('Sender','Connect mode: click node A then node B to create fiber');
    return;
  }
  if (tool === 'toolSender') createNode('Sender', x, y);
  if (tool === 'toolReceiver')   createNode('Receiver',   x, y);
  if (tool === 'toolEve')   createNode('eve',   x, y);
  if (tool === 'toolPassive_eve')   createNode('passive_eve', x, y);
});

/* create node */
function createNode(type, x=120, y=80, skipSave=false){
  if (!skipSave) saveState();
  // Normalize type for passive eve
  if (type === 'Passive_eve') type = 'passive_eve';
  const id = 'n' + (nextId++);
  const el = document.createElement('div'); el.className='node'; el.id='node-'+id;
  el.dataset.id = id; el.dataset.type = type;
  el.style.left = x+'px'; el.style.top = y+'px';
  const emoji = type==='Sender' ? 'üñ•Ô∏è' : type==='Receiver' ? 'üñ•Ô∏è' : type==='eve' ? 'üïµÔ∏è' : 'ü•∑';
  el.innerHTML = `<div class="avatar">${emoji}</div><div class="label">${type.toUpperCase()}</div>`;
  workspace.appendChild(el);
  nodes.push({id,type,el,x,y});
  makeDraggable(el);
  el.addEventListener('click', ev => {
  ev.stopPropagation();
  selectedNodeId = id;
  document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
  el.classList.add('selected');
  nodeClicked(id);
});
  renderCables();
}

/* draggable nodes (pointer-based) */
function makeDraggable(el){
  el.addEventListener('pointerdown', e=>{
    dragging = el; el.setPointerCapture(e.pointerId);
    const crect = workspace.getBoundingClientRect();
    dragOffset.x = e.clientX - crect.left - parseFloat(el.style.left);
    dragOffset.y = e.clientY - crect.top  - parseFloat(el.style.top);
    el.style.cursor='grabbing';
  });
}
window.addEventListener('pointermove', e=>{
  if (!dragging) return;
  const crect = workspace.getBoundingClientRect();
  let nx = e.clientX - crect.left - dragOffset.x;
  let ny = e.clientY - crect.top - dragOffset.y;
  nx = Math.max(6, Math.min(nx, crect.width - 126));
  ny = Math.max(6, Math.min(ny, crect.height - 126));
  dragging.style.left = nx + 'px'; dragging.style.top = ny + 'px';
  const id = dragging.dataset.id; const nd = nodes.find(n=>n.id===id); if (nd){ nd.x = nx; nd.y = ny; renderCables(); }
});
window.addEventListener('pointerup', e=>{ if (dragging){ dragging.style.cursor='grab'; dragging.releasePointerCapture(e.pointerId); dragging=null; } });

/* node click: for connect mode or normal select */
function nodeClicked(id){
  if (connectMode){
    if (!connectStart){ connectStart = id; const nd = nodes.find(n=>n.id===id); nd.el.style.outline='2px solid rgba(14,165,233,0.9)'; showBubble('Sender','Now click the node to connect to'); return; }
    if (connectStart === id){ showBubble('Sender','Cannot connect node to itself'); connectStart=null; connectMode=false; cleanupOutlines(); return; }
    createCable(connectStart, id);
    connectMode = false; cleanupOutlines();
    showBubble('Sender','Fiber connected');
    return;
  }
  const nd = nodes.find(n=>n.id===id);
  if (nd) showBubble(nd.type==='Sender'?'Sender':nd.type==='Receiver'?'Receiver':'Eve', `${nd.type.toUpperCase()} selected`);
}
function cleanupOutlines(){ nodes.forEach(n=> n.el.style.outline='none'); }

/* create cable between two nodes (SVG path) */
/* create cable between two nodes (SVG path) */
/* create cable between two nodes (SVG path) */
function createCable(fromId, toId, skipSave=false) {
  if (!skipSave) saveState();
  if (cables.some(c => (c.fromId === fromId && c.toId === toId) || (c.fromId === toId && c.toId === fromId))) return;

  const fromNode = nodes.find(n => n.id === fromId);
  const toNode   = nodes.find(n => n.id === toId);
  
  // Check if either connected node is an Eve or Passive Eve.
  const isEveLink = (fromNode.type === 'eve' || toNode.type === 'eve');
  const isPassiveEveLink = (fromNode.type === 'passive_eve' || toNode.type === 'passive_eve');

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  
  // Set the color based on the node type
  if (isEveLink) {
    path.setAttribute('stroke', 'rgba(239,68,68,0.9)'); // Red for active Eve
  } else if (isPassiveEveLink) {
    path.setAttribute('stroke', 'rgba(239,68,68,0.9)'); // Red for Passive Eve
  } else {
    path.setAttribute('stroke', 'rgba(6,182,212,0.9)'); // Blue for normal connection
  }

  path.setAttribute('stroke-width', '6');
  path.setAttribute('fill', 'none');
  svg.appendChild(path);

  cables.push({ fromId, toId, path });
  renderCables();
}

/* render all cables */
/* render all cables */
/* render all cables */
function renderCables() {
  // ensure defs for gradient maybe
  ensureDefs();
  cables.forEach(c => {
    const a = nodes.find(n => n.id === c.fromId);
    const b = nodes.find(n => n.id === c.toId);
    if (!a || !b) return;
    const ax = a.x + 60,
      ay = a.y + 60,
      bx = b.x + 60,
      by = b.y + 60;
    const dx = bx - ax;
    const cp1x = ax + dx * 0.25,
      cp1y = ay - 80;
    const cp2x = ax + dx * 0.75,
      cp2y = by - 80;
    const d = `M ${ax} ${ay} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${bx} ${by}`;
    c.path.setAttribute('d', d);

    // Check for active Eve
    const eveNode = nodes.find(n => n.type === 'eve');
    // Check for passive Eve
    const passiveEveNode = nodes.find(n => n.type === 'passive_eve');

    // Change color based on which node is near the path
    if (eveNode && true && isNodeNearPath(eveNode, c.path)) {
      c.path.setAttribute('stroke', 'rgba(239,68,68,0.9)'); // Red for active Eve
    } else if (passiveEveNode && isNodeNearPath(passiveEveNode, c.path)) {
      c.path.setAttribute('stroke', 'rgba(239,68,68,0.9)'); // Red for Passive Eve
    } else {
      c.path.setAttribute('stroke', 'rgba(6,182,212,0.9)'); // Blue for normal connection
    }
  });
}

/* small SVG defs */
function ensureDefs(){
  if (svg.querySelector('defs')) return;
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const grad = document.createElementNS('http://www.w3.org/2000/svg','linearGradient'); grad.id='g1'; grad.setAttribute('x1','0%'); grad.setAttribute('x2','100%');
  const s1 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s1.setAttribute('offset','0%'); s1.setAttribute('stop-color','#06b6d4');
  const s2 = document.createElementNS('http://www.w3.org/2000/svg','stop'); s2.setAttribute('offset','100%'); s2.setAttribute('stop-color','#8b5cf6');
  grad.appendChild(s1); grad.appendChild(s2);
  defs.appendChild(grad); svg.appendChild(defs);
}

/* detect if a node center is near a path's bbox approx */
function isNodeNearPath(node, pathEl){
  const bbox = pathEl.getBBox();
  const nx = node.x + 60, ny = node.y + 60;
  return nx > bbox.x - 30 && nx < bbox.x + bbox.width + 30 && ny > bbox.y - 30 && ny < bbox.y + bbox.height + 30;
}

/* -------------------------
   Sender UI: pickers
   ------------------------- */
function buildSenderPickers(){
  const n = parseInt($('numQ').value,10);
  SenderBits = new Array(n).fill(0);
  SenderBases = new Array(n).fill('+');
  perPhotonEve = new Array(n).fill(null);
  ReceiverChoices = new Array(n).fill(null);
  ReceiverResults = new Array(n).fill(null);
  const container = $('SenderPickers'); container.innerHTML='';
  for (let i=0;i<n;i++){
    const div = document.createElement('div'); div.className='qubit-picker';
    div.innerHTML = `<div style="font-weight:700">Q${i+1}</div>
      <label class="small">Bit</label>
      <select id="abit-${i}"><option value="0">0</option><option value="1">1</option></select>
      <label class="small" style="margin-top:6px">Basis</label>
      <select id="abase-${i}"><option value="+">+</option><option value="x">x</option></select>`;
    container.appendChild(div);
  }
  $('ReceiverArea').innerHTML=''; $('cipherBox').style.display='none'; $('sharedKeyBox').innerHTML=''; $('mismatchInfo').innerText='';
  /* $('encryptBtn').disabled = true; */
  $('SenderNote').innerText = 'Prepared ‚Äî set bits & bases or Randomize.';
}
$('prepareBtn').addEventListener('click', buildSenderPickers);
$('numQ').addEventListener('change', buildSenderPickers);
$('randBtn').addEventListener('click', ()=>{
  buildSenderPickers();
  const n = parseInt($('numQ').value,10);
  for (let i=0;i<n;i++){ $('abit-'+i).value = randBit(); $('abase-'+i).value = randBasis(); }
});
function renderAnalysisPanel() {
  const data = window.lastExpData || {};

  // Circuit diagram
  if (data.circuit_diagram_url) {
    document.getElementById('circuitDiagram').innerHTML =
      `<h3>Circuit Diagram</h3>
       <div style='background:#133c23;padding:12px;border-radius:8px;'>
         <img src="${data.circuit_diagram_url}" style="width:100%;max-width:600px;background:#fff;border-radius:8px;">
       </div>`;
  } else {
    document.getElementById('circuitDiagram').innerHTML =
      "<h3>Circuit Diagram</h3><div style='background:#133c23;padding:12px;border-radius:8px;'>[No diagram]</div>";
  }

  // Counts as a readable list
  let counts = data.counts_bob || data.counts || data.counts_eve || null;
if (counts && Object.keys(counts).length > 0) {
  let countsHtml = "<h3>Measurement Counts</h3><div style='background:#133c23;padding:12px;border-radius:8px;max-height:220px;overflow:auto;'><ul style='list-style:none;padding:0;margin:0;'>";
  Object.entries(counts).forEach(([key, value]) => {
    countsHtml += `<li style="font-family:monospace;font-size:15px;margin-bottom:2px;">${key}: <b>${value}</b></li>`;
  });
  countsHtml += "</ul></div>";
  document.getElementById('histogram').innerHTML = countsHtml;
} else {
  document.getElementById('histogram').innerHTML = "<h3>Measurement Counts</h3><div style='background:#133c23;padding:12px;border-radius:8px;'>No measurement data.</div>";
}

  // QBER calculation
  let qber = data.qber !== undefined ? data.qber : (data.loss !== undefined ? (data.loss * 100) : "N/A");
  document.getElementById('qberCalc').innerHTML = `<h3>QBER Calculation</h3>
    <div style='background:#133c23;padding:12px;border-radius:8px;'>
      QBER = ${typeof qber === "number" ? qber.toFixed(2) : qber}%
    </div>`;
}
/* -------------------------
   Send photons (animated along path)
   ------------------------- */
$('sendBtn').addEventListener('click', ()=>{
  const Sender = nodes.find(n=>n.type==='Sender'), Receiver = nodes.find(n=>n.type==='Receiver');
  if (!Sender || !Receiver){ alert('Place Sender and Receiver on the canvas'); return; }
  const route = findRoute(Sender, Receiver);
  if (!route){ alert('Connect Sender and Receiver using Fiber (or connect via Eve)'); return; }
  // read inputs
  const n = parseInt($('numQ').value,10);
  SenderBits = new Array(n); SenderBases = new Array(n);
  for (let i=0;i<n;i++){ SenderBits[i] = parseInt($('abit-'+i).value,10); SenderBases[i] = $('abase-'+i).value; }
  ReceiverChoices = new Array(n).fill(null); ReceiverResults = new Array(n).fill(null); perPhotonEve = new Array(n).fill(null);
  photonsInFlight = n;
  $('ReceiverArea').innerHTML=''; $('cipherBox').style.display='none'; $('sharedKeyBox').innerHTML=''; $('mismatchInfo').innerText='';
  showBubble('Sender','Sending photons...');
  const delay = 140;
  for (let i=0;i<n;i++){ ((idx)=> setTimeout(()=> sendPhoton(idx, route), idx*delay))(i); }
});

/* find route array of nodes between Sender and Receiver (uses cables if present) */
function findRoute(Sender,Receiver){
  // direct cable?
  const direct = cables.find(c=> (c.fromId===Sender.id && c.toId===Receiver.id) || (c.fromId===Receiver.id && c.toId===Sender.id));
  if (direct) return [Sender,Receiver];
  // via Eve if connected both sides and enabled
  const eve = nodes.find(n=>n.type==='eve');
  if (eve && true){
    const c1 = cables.find(c=> (c.fromId===Sender.id && c.toId===eve.id) || (c.fromId===eve.id && c.toId===Sender.id));
    const c2 = cables.find(c=> (c.fromId===Receiver.id && c.toId===eve.id) || (c.fromId===eve.id && c.toId===Receiver.id));
    if (c1 && c2) return [Sender,eve,Receiver];
  }
  // BFS on cable graph
  const graph = {};
  nodes.forEach(n=> graph[n.id]=[]);
  cables.forEach(c=> { graph[c.fromId].push(c.toId); graph[c.toId].push(c.fromId); });
  const q = [[Sender.id]]; const visited = new Set([Sender.id]);
  while(q.length){
    const path = q.shift(), last = path[path.length-1];
    if (last === Receiver.id) return path.map(id=> nodes.find(n=>n.id===id));
    for (const nb of graph[last] || []) if (!visited.has(nb)) { visited.add(nb); q.push([...path, nb]); }
  }
  return null;
}

/* send single photon along route: animate along the SVG path that connects appropriate two nodes per segment */
function sendPhoton(index, route){
  // build a combined path for route: concat cubic segments between consecutive nodes by looking up cable path
  const segmentPaths = [];
  for (let i=0;i<route.length-1;i++){
    const from = route[i], to = route[i+1];
    // find cable between them
    const cable = cables.find(c=> (c.fromId===from.id && c.toId===to.id) || (c.fromId===to.id && c.toId===from.id));
    if (!cable) { console.warn('No cable for segment', from,to); return; }
    segmentPaths.push(cable.path);
  }
  if (segmentPaths.length===0) return;

  // create photon element
  const p = document.createElement('div'); p.className='photon';
  const badge = document.createElement('div'); badge.className='basis'; badge.textContent = SenderBases[index];
  p.appendChild(badge);
  document.body.appendChild(p);

  // animate along piecewise paths sequentially using getPointAtLength
  let segIndex = 0;
  function animateAlongPath(seg){
    const path = seg;
    const len = path.getTotalLength();
    const duration = 420 + Math.random()*300;
    const start = performance.now();
    function frame(now){
      const t = Math.min(1,(now-start)/duration);
      const pt = path.getPointAtLength(len * t);
      p.style.left = (pt.x - 20) + 'px'; p.style.top = (pt.y - 20) + 'px';
      if (t < 1) requestAnimationFrame(frame);
      else {
        // arrived at segment end (node)
        const arrivedNodeId = (()=> {
          const attr = path.getAttribute('d'); // can't easily get endpoint; instead infer based on segIndex
          // we will rely on route array: when segmentPaths[segIndex] corresponds to route[segIndex] -> route[segIndex+1]
          return route[segIndex+1].id;
        })();
        // if arrived at Eve node and Eve enabled, perform intercept-resend
        const arrivedNode = nodes.find(n=> n.id === arrivedNodeId);
        if (arrivedNode && arrivedNode.type === 'eve' && true) {
  // Eve measures with random basis then determines resent bit
  const eveBasis = randBasis();
  const eveMeasured = (eveBasis === SenderBases[index]) ? SenderBits[index] : randBit();
  perPhotonEve[index] = { eveBasis, resentBit: eveMeasured, intercepted: true };
  showBubble('Eve', `Intercepted Q${index+1} ‚Äî measured ${eveBasis}`);
  placeTransient(arrivedNode, `E:${eveMeasured}`);
  // remove badge (Eve hides basis)
  if (badge) badge.remove();
  // continue to next segment (photon now becomes the resent bit)
  segIndex++;
  if (segIndex < segmentPaths.length) animateAlongPath(segmentPaths[segIndex]);
  else finishAtReceiver();
} else if (arrivedNode && arrivedNode.type === 'passive_eve') {
  showBubble('Passive_eve', `Observed Q${index+1}`);
  placeTransient(arrivedNode, `P:${SenderBits[index]}`);
  // Passive Eve does not affect the photon, so it continues unchanged
  segIndex++;
  if (segIndex < segmentPaths.length) animateAlongPath(segmentPaths[segIndex]);
  else finishAtReceiver();
} else {
  // normal node transit
  segIndex++;
  if (segIndex < segmentPaths.length) animateAlongPath(segmentPaths[segIndex]);
  else finishAtReceiver();
}
      }
    }
    requestAnimationFrame(frame);
  }

  function finishAtReceiver(){
    if (badge) badge.remove();
    const txt = document.createElement('div'); txt.textContent = SenderBits[index];
    p.appendChild(txt);
    animateReceiverPulse(route[route.length-1]);
    setTimeout(()=>{ p.remove(); photonsInFlight--; if (photonsInFlight===0) { showBubble('Receiver','All photons arrived ‚Äî measure them'); buildReceiverUI(); } }, 600);
  }

  // start animation on first path
  animateAlongPath(segmentPaths[0]);
}

/* small transient marker near node */
function placeTransient(node, text){
  const rect = workspace.getBoundingClientRect();
  const m = document.createElement('div'); m.className='qubit-picker'; m.style.position='absolute';
  m.style.left = (rect.left + node.x + 30) + 'px'; m.style.top = (rect.top + node.y + 120) + 'px'; m.style.opacity=0.08;
  m.style.background='rgba(255,255,255,0.02)'; m.innerHTML = `<div style="font-size:12px">${text}</div>`;
  document.body.appendChild(m); setTimeout(()=>m.remove(),900);
}

/* receiver pulse */
function animateReceiverPulse(node){
  const r = workspace.getBoundingClientRect();
  const cx = r.left + node.x + 60, cy = r.top + node.y + 60;
  const pulse = document.createElement('div'); pulse.style.position='absolute'; pulse.style.left=(cx-35)+'px'; pulse.style.top=(cy-35)+'px';
  pulse.style.width='70px'; pulse.style.height='70px'; pulse.style.borderRadius='50%'; pulse.style.background='radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 40%)';
  document.body.appendChild(pulse);
  pulse.animate([{transform:'scale(0)',opacity:1},{transform:'scale(1.05)',opacity:0.6},{transform:'scale(1.6)',opacity:0}],{duration:520,easing:'ease-out'});
  setTimeout(()=>pulse.remove(),600);
}

/* -------------------------
   Receiver UI & measurement
   ------------------------- */
function buildReceiverUI(){
  const area = $('ReceiverArea'); area.innerHTML='';
  for (let i=0;i<SenderBits.length;i++){
    const card = document.createElement('div'); card.className='measure-card'; card.id='m-'+i; card.style.marginBottom='8px';
    card.innerHTML = `<div style="font-weight:700">Q${i+1}</div>
      <div class="small" style="margin-top:6px">Choose basis</div>
      <div style="display:flex;gap:6px;justify-content:center;margin-top:6px">
        <button class="btn secondary" onclick="userMeasure(${i}, '+')">+</button>
        <button class="btn secondary" onclick="userMeasure(${i}, 'x')">x</button>
      </div>
      <div id="res-${i}" style="margin-top:6px">‚Äî</div>`;
    area.appendChild(card);
  }
}

/* measurement logic (uses perPhotonEve if intercepted) */
function userMeasure(index, basis){
  if (ReceiverChoices[index] !== null) return;
  ReceiverChoices[index] = basis;
  const eveRec = perPhotonEve[index];
  if (eveRec && eveRec.intercepted){
    if (basis === SenderBases[index]) ReceiverResults[index] = eveRec.resentBit;
    else ReceiverResults[index] = randBit();
  } else {
    if (basis === SenderBases[index]) ReceiverResults[index] = SenderBits[index];
    else ReceiverResults[index] = randBit();
  }
  $('res-'+index).innerText = `Basis ${basis} ‚Üí Bit ${ReceiverResults[index]}`;
  showBubble('Receiver', `Measured Q${index+1}`);
}

/* -------------------------
   Sift & Key derivation
   ------------------------- */
$('siftBtn').addEventListener('click', async ()=>{
  if (!SenderBits.length){ alert('No qubits sent yet'); return; }
  if (ReceiverChoices.some(v=> v===null)){ alert('Please measure all qubits before sifting'); return; }
  const keyBits = [], mismatches = [];
  for (let i=0;i<SenderBits.length;i++){
    if (SenderBases[i] === ReceiverChoices[i]){
      keyBits.push(SenderBits[i]);
      if (ReceiverResults[i] !== SenderBits[i]) mismatches.push(i);
    }
  }
  const keyBox = $('sharedKeyBox'); keyBox.innerHTML='';
  if (keyBits.length === 0) keyBox.innerHTML = `<div class="final-key">No shared key (no matching bases)</div>`;
  else {
    keyBox.innerHTML = `<div class="final-key">üîë ${keyBits.join('')}</div>`;
    showBubble('Sender','Shared key established!');
    derivedKey = await deriveAesKeyFromBits(keyBits);
    $('encryptBtn').disabled = false;
  }
  const mi = $('mismatchInfo');
  if (mismatches.length > 0){
    mi.innerText = `Detected ${mismatches.length} mismatches ‚Äî possible Eve interference`;
    mi.style.color = '#ffb3b3';
    mismatches.forEach(i=> { const el = $('m-'+i); if (el) el.style.border = '2px solid #ef4444'; });
  } else { mi.innerText = 'No mismatches detected in matched positions'; mi.style.color = '#bfe8ff'; }
});

/* derive AES key from bits via SHA-256 (demo KDF) */
async function deriveAesKeyFromBits(bits){
  const encoder = new TextEncoder();
  const h = await crypto.subtle.digest('SHA-256', encoder.encode(bits.join('')));
  const keyBytes = h.slice(0,16);
  return crypto.subtle.importKey('raw', keyBytes, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
}

/* -------------------------
   Encrypt & transmit ciphertext
   ------------------------- */
/* $('encryptBtn').addEventListener('click', async function() {
    const message = document.getElementById('userMessage').value || "QKD demo";
    let exp = window.lastExpType;
    if (!exp || (exp !== "exp1" && exp !== "exp2")) return;
    let res = await fetch(`/run/${exp}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message })
    }); 
    let data = await res.json();
    window.lastExpData = data; // update global so analysis panel is correct too
    // Update output panel with new result!
    document.getElementById("output").innerText = formatNarration(data, exp === "exp3");
    document.getElementById("cryptoOutput").innerHTML =
      `<div><b>Original Message:</b> ${data.original_message}</div>
       <div><b>Encrypted (hex):</b> <span style="font-family:monospace">${data.encrypted_message_hex}</span></div>
       <div><b>Decrypted:</b> ${data.decrypted_message}</div>`;
}); */

function bufferToHex(buf){
  const a = new Uint8Array(buf); return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* animate ciphertext: move linearly from start node center to end center */
function animateCipher(route, hex, onArrive){
  const rect = workspace.getBoundingClientRect();
  const start = {x: rect.left + route[0].x + 60 - 20, y: rect.top + route[0].y + 60 - 20};
  const end   = {x: rect.left + route[route.length-1].x + 60 - 140, y: rect.top + route[route.length-1].y + 60 - 20};
  const box = document.createElement('div'); box.className='photon'; box.style.width='160px'; box.style.height='44px'; box.style.borderRadius='10px';
  box.style.left = start.x + 'px'; box.style.top = start.y + 'px'; box.style.background='linear-gradient(90deg,#06b6d4,#8b5cf6)'; box.style.color='#fff';
  box.style.lineHeight='44px'; box.style.textAlign='center'; box.textContent = 'ciphertext ‚Üí'; document.body.appendChild(box);
  const total = Math.hypot(end.x - start.x, end.y - start.y);
  const duration = Math.max(600, total*1.5); const startTime = performance.now();
  const eveNode = nodes.find(n=>n.type==='eve');
  function frame(now){
    const t = Math.min(1,(now - startTime)/duration);
    const nx = start.x + (end.x - start.x)*t; const ny = start.y + (end.y - start.y)*t; box.style.left=nx+'px'; box.style.top=ny+'px';
    if (eveNode && true){
      const eveCenterX = rect.left + eveNode.x + 60;
      if (nx > eveCenterX - 20 && nx < eveCenterX + 20) showBubble('Eve','Eve sniffing ciphertext (cannot decrypt)');
    }
    if (t < 1) requestAnimationFrame(frame); else { box.remove(); onArrive && onArrive(); }
  }
  requestAnimationFrame(frame);
}

/* -------------------------
   Helper UI wiring
   ------------------------- */
$('howBtn').addEventListener('click', ()=> $('modal').style.display='flex');
$('closeModal').addEventListener('click', ()=> $('modal').style.display='none');

/* initial pickers and hint */
buildSenderPickers(); showBubble('Sender','Drag Sender & Receiver from toolbox to the canvas');

/* expose userMeasure for inline onclicks */
window.userMeasure = userMeasure;

/* END OF SCRIPT */
</script>
<script>
  async function runExp1() {
    let res = await fetch("/run/exp1");
    let data = await res.json();
    document.getElementById("output").innerText = JSON.stringify(data, null, 2);
  }

  async function runExp2() {
    let res = await fetch("/run/exp2");
    let data = await res.json();
    document.getElementById("output").innerText = JSON.stringify(data, null, 2);
  }
</script>
<script>
function getSenderBitsBases() {
  // Returns { bits: [...], bases: [...] }
  const n = parseInt(document.getElementById('numQ').value, 10);
  let bits = [], bases = [];
  for (let i = 0; i < n; i++) {
    bits.push(parseInt(document.getElementById('abit-' + i).value, 10));
    bases.push(document.getElementById('abase-' + i).value);
  }
  return { bits, bases };
}

function getReceiverBases() {
  // Returns array of Receiver's chosen bases
  return ReceiverChoices.slice();
}

function getEveBases(n) {
  // Generate random Eve bases (or use user input if available)
  let bases = [];
  for (let i = 0; i < n; i++) bases.push(randBasis());
  return bases;
}

/*function detectTopology() {
  // Returns "exp1", "exp2", or "exp3" based on canvas connections
  const Sender = nodes.find(n => n.type === 'Sender');
  const Receiver = nodes.find(n => n.type === 'Receiver');
  const eve = nodes.find(n => n.type === 'eve');
  if (!Sender || !Receiver) return null;
  const direct = cables.find(c => 
      (c.fromId === Sender.id && c.toId === Receiver.id) ||
      (c.fromId === Receiver.id && c.toId === Sender.id)
  );
  // Find if Eve is present and both Sender-Eve and Eve-Receiver cables exist
  let eveIntercepting = false;
  if (eve) {
      const c1 = cables.find(c => (c.fromId === Sender.id && c.toId === eve.id) || (c.fromId === eve.id && c.toId === Sender.id));
      const c2 = cables.find(c => (c.fromId === Receiver.id && c.toId === eve.id) || (c.fromId === eve.id && c.toId === Receiver.id));
      // Eve intercepts if both cables exist and the cable is red (your renderCables logic sets this)
      if (c1 && c2) {
          // Check if either cable is red (intercepting)
          const eveInterceptCable = [c1, c2].find(c => c.path.getAttribute('stroke').includes('239,68,68')); // rgba(239,68,68,0.9)
          if (eveInterceptCable) eveIntercepting = true;
      }
  }
  // Decide experiment
  let exp = null;
  if (eve && eveIntercepting) {
      exp = "exp3";
  } else if (direct) {
      exp = "exp1";
  } else {
      exp = "exp2";
  }
  return exp;
}*/

function formatResult(data, expType) {
  let html = "";
  html += `Sender Bits: [${data.Sender_bits || data.agoodbits || ""}]\n`;
  html += `Sender Bases: [${data.Sender_bases || ""}]\n`;
  html += `Receiver Bases:   [${data.Receiver_bases || ""}]\n`;
  if (expType === "exp3") html += `Eve Bases:   [${data.eve_bases || ""}]\n`;
  html += `\nFidelity: ${(data.fidelity * 100).toFixed(2)}%\nLoss: ${(data.loss * 100).toFixed(2)}%\n`;
  if (data.counts) html += `\nMeasurement Counts:\n${JSON.stringify(data.counts, null, 2)}\n`;
  html += `\nSifted Key (Sender): [${data.agoodbits || ""}]\nSifted Key (Receiver):   [${data.bgoodbits || ""}]\n`;
  return html;
}
function detectExperimentType(){
  const Sender = nodes.find(n => n.type === 'Sender');
  const Receiver = nodes.find(n => n.type === 'Receiver');
  const eve = nodes.find(n => n.type === 'eve');
  const passiveEve = nodes.find(n => n.type === 'passive_eve');
  if (!Sender || !Receiver) return null;

  // Direct cable between Sender and Receiver
  const directCable = cables.find(c =>
    (c.fromId === Sender.id && c.toId === Receiver.id) ||
    (c.fromId === Receiver.id && c.toId === Sender.id)
  );

  // Passive Eve on the cable
  if (passiveEve && directCable && isNodeNearPath(passiveEve, directCable.path)) {
    return "exp4"; // Passive Eve experiment
  }

  // If direct cable exists and is red, treat as Eve intercepting
  if (directCable && directCable.path.getAttribute('stroke') === 'rgba(239,68,68,0.9)') {
    return "exp3"; // Eve intercepts (single red cable)
  }

  // If both Sender‚ÄìEve and Eve‚ÄìReceiver cables exist, treat as Eve intercepting
  const SenderToEve = eve && cables.some(c =>
    (c.fromId === Sender.id && c.toId === eve.id) ||
    (c.fromId === eve.id && c.toId === Sender.id)
  );
  const eveToReceiver = eve && cables.some(c =>
    (c.fromId === eve.id && c.toId === Receiver.id) ||
    (c.fromId === Receiver.id && c.toId === eve.id)
  );
  if (eve && SenderToEve && eveToReceiver) {
    return "exp3";   // Eve intercepts (two-cable path)
  }

  if (directCable) {
    // --- Error Mitigation toggle logic ---
    if (document.getElementById('toggleErrorMitigation')?.checked) {
      return "exp1"; // Run exp1 if error mitigation is checked
    }
    return "exp2";   // Direct Sender‚ÜîReceiver, no Eve
  }
}
document.getElementById("runExpBtn").onclick = async function() {
    const exp = detectExperimentType();
    if (!exp) {
        document.getElementById("output").innerText = "No connection between Sender and Receiver.";
        return;
    }
// After running the experiment and getting the exp type and data:
window.lastExpType = exp; // Save the last experiment type for later use

/* if (exp === "exp1" || exp === "exp2") {
    const msgBlock = document.getElementById('messageInputBlock');
if (msgBlock) msgBlock.style.display = 'block';
    document.getElementById('encryptBtn').disabled = false;
} else {
    document.getElementById('messageInputBlock').style.display = 'none';
    document.getElementById('encryptBtn').disabled = true;
} */
    document.getElementById("output").innerText = "Running experiment" + "...";
    const res = await fetch("/run/" + exp, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({}) // No message sent here!
});
    const data = await res.json();
    window.lastExpData = data; // --- THIS IS THE KEY CHANGE ---
    document.getElementById("output").innerText = formatNarration(data, exp === "exp3");

    // Show crypto results only for exp2, or exp4 if encryption_allowed
   /* if (
        (exp === "exp2" && data.original_message !== undefined) ||
        (exp === "exp4" && data.encryption_allowed)
    ) {
        document.getElementById("cryptoOutput").innerHTML =
          `<div><b>Original Message:</b> ${data.original_message}</div>
           <div><b>Encrypted (hex):</b> <span style="font-family:monospace">${data.encrypted_message_hex}</span></div>
           <div><b>Decrypted:</b> ${data.decrypted_message}</div>`;
    } else {
        document.getElementById("cryptoOutput").innerHTML = "";
        if (exp === "exp3") {
            document.getElementById("cryptoOutput").innerHTML =
              `<div style="color:#ef4444"><b>Cannot encrypt/decrypt:</b> Key is not secret due to eavesdropping (Eve present in channel).</div>`;
        }
        if (exp === "exp4" && data.qber !== undefined && !data.encryption_allowed) {
            document.getElementById("cryptoOutput").innerHTML =
              `<div style="color:#ef4444"><b>Cannot encrypt/decrypt:</b> QBER too high (${data.qber.toFixed(2)}%). Key is not secure.</div>`;
        }
    } */

    // Show or hide the message input block based on experiment type
    if (exp === "exp1" || exp === "exp2") {
        const msgBlock = document.getElementById('messageInputBlock');
    if (msgBlock) msgBlock.style.display = 'block';
    } else {
        const msgBlock = document.getElementById('messageInputBlock');
        if (msgBlock) msgBlock.style.display = 'none';
    }
};

// Format narration and results
function formatNarration(data, hasEve) {
    let out = "";
    out += "Step 1: Sender prepares random bits and bases\n";
    out += "  Sender bits:  " + JSON.stringify(data.Sender_bits) + "\n";
    out += "  Sender bases: " + JSON.stringify(data.Sender_bases) + "\n";
    if (hasEve) {
        out += "\nStep 2: Eve intercepts and measures with random bases\n";
        out += "  (Eve's actions introduce errors)\n";
    }
    out += "\nStep " + (hasEve ? "3" : "2") + ": Receiver measures with random bases\n";
    out += "  Receiver bases:   " + JSON.stringify(data.Receiver_bases) + "\n";
    out += "  Receiver bits:    " + JSON.stringify(data.Receiver_bits) + "\n";
    out += "\nStep " + (hasEve ? "4" : "3") + ": Sifted keys (matching bases)\n";
    out += "  Sender sifted: " + JSON.stringify(data.agoodbits) + "\n";
    out += "  Receiver sifted:   " + JSON.stringify(data.bgoodbits) + "\n";
    out += "\nFidelity: " + (data.fidelity * 100).toFixed(2) + "%\n";
    out += "Loss: " + (data.loss * 100).toFixed(2) + "%\n";
    if (data.error_corrected_key) {
    out += "\nKey after Error Correction: " + data.error_corrected_key + "\n";
    }
    if (data.final_secret_key) {
    out += "Final Secret Key: " + data.final_secret_key + "\n";
    }
    return out;
}

/* -------------------------
   Experiment detection
   ------------------------- */

function saveState() {
  // Save a deep copy of nodes and cables for undo
  undoStack.push({
    nodes: JSON.parse(JSON.stringify(nodes)),
    cables: JSON.parse(JSON.stringify(cables))
  });
  // Clear redo stack on new action
  redoStack = [];
}

function restoreState(state) {
  // Remove all DOM nodes and cables
  document.querySelectorAll('.node').forEach(el => el.remove());
  svg.querySelectorAll('path').forEach(el => el.remove());
  // Restore state
  nodes = JSON.parse(JSON.stringify(state.nodes));
  cables = JSON.parse(JSON.stringify(state.cables));
  // Rebuild DOM
  nodes.forEach(n => {
    createNode(n.type, n.x, n.y, true); // skipSave=true
  });
  cables.forEach(c => {
    createCable(c.fromId, c.toId, true); // skipSave=true
  });
  renderCables();
}
document.getElementById('undoBtn').onclick = function() {
  if (undoStack.length === 0) return;
  const prev = undoStack.pop();
  redoStack.push({
    nodes: JSON.parse(JSON.stringify(nodes)),
    cables: JSON.parse(JSON.stringify(cables))
  });
  restoreState(prev);
};

document.getElementById('redoBtn').onclick = function() {
  if (redoStack.length === 0) return;
  const next = redoStack.pop();
  undoStack.push({
    nodes: JSON.parse(JSON.stringify(nodes)),
    cables: JSON.parse(JSON.stringify(cables))
  });
  restoreState(next);
};

document.getElementById('clearBtn').onclick = function() {
  saveState();
  // Remove all nodes and cables from DOM and memory
  document.querySelectorAll('.node').forEach(el => el.remove());
  svg.querySelectorAll('path').forEach(el => el.remove());
  nodes = [];
  cables = [];
  renderCables();
};

document.getElementById('deleteBtn').onclick = function() {
  if (!selectedNodeId) return;
  saveState();
  // Remove node from nodes array
  nodes = nodes.filter(n => n.id !== selectedNodeId);
  // Remove cables connected to this node
  cables = cables.filter(c => c.fromId !== selectedNodeId && c.toId !== selectedNodeId);
  // Remove node element
  const el = document.getElementById('node-' + selectedNodeId);
  if (el) el.remove();
  // Remove cables from SVG
  renderCables();
  selectedNodeId = null;
};
function renderHistogram(counts, targetId = 'histogram', width = 400, height = 300) {
  if (!counts) return;
  const labels = Object.keys(counts);
  const data = Object.values(counts);
  const options = {
    chart: { type: 'bar', height: height, width: width, background: 'transparent' },
    series: [{ name: 'Counts', data: data }],
    xaxis: { categories: labels, labels: { style: { colors: '#e9f7ff', fontSize: '12px' } } },
    yaxis: { labels: { style: { colors: '#e9f7ff' } } },
    colors: ['#10b981'],
    grid: { borderColor: '#183c23' }
  };
  document.getElementById(targetId).innerHTML = "";
  new ApexCharts(document.getElementById(targetId), options).render();
}
</script>
  <!-- <div id="messageInputBlock" style="display:none; margin:16px 0;">
  <label for="userMessage" style="font-weight:700;">Message to encrypt:</label>
  <input type="text" id="userMessage" style="width:60%;padding:6px 10px;border-radius:6px;border:1px solid #10b981;background:rgba(255,255,255,0.07);color:#e9f7ff;">
  <button id="encryptBtn" class="btn secondary" style="margin-left:8px;">Encrypt & Send</button>
</div>  -
<div id="cryptoOutput" style="margin:10px 0 0 0; color:#bfe8ff;"></div> -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
<script>
  // ...all your JavaScript code...
  document.getElementById('showAnalysisBtn').onclick = function() {
  document.getElementById('analysisPanel').style.display = 'flex';
  renderAnalysisPanel();
};
document.getElementById('closeAnalysisBtn').onclick = function() {
  document.getElementById('analysisPanel').style.display = 'none';
};
</script>
<div id="histogramModal" class="modal-back" style="display:none;align-items:center;justify-content:center;z-index:10000;">
  <div class="modal" style="max-width:90vw;max-height:90vh;overflow:auto;">
    <h3>Measurement Histogram</h3>
    <div id="histogramModalChart"></div>
    <div style="text-align:right;margin-top:12px">
      <button onclick="document.getElementById('histogramModal').style.display='none'" class="btn">Close</button>
    </div>
  </div>
</div>
</body>
</html>